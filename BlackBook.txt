\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{color,xcolor}
\usepackage{parskip}
\usepackage{titling}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{lipsum}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{array}
\usepackage{enumitem}
\usepackage{minted}
\usepackage{background}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{tcolorbox}
% Define a blue box for section headers
\definecolor{customblue}{RGB}{210, 225, 245} % Soft blue shade

\newtcolorbox{bluebox}{
  colback=customblue,
  colframe=customblue,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  left=6pt,
  right=6pt,
  top=3pt,
  bottom=3pt,
  width=\textwidth,
  boxsep=0pt
}
\backgroundsetup{
  scale=1,
  color=black,
  opacity=1,
  angle=0,
  position=current page.south west,
  contents={
    \begin{tikzpicture}[remember picture, overlay]
      \draw[line width=1pt]
        ($(current page.north west)+(0.5in,-0.5in)$) rectangle
        ($(current page.south east)+(-0.5in,0.5in)$);
    \end{tikzpicture}
  }
}

\begin{document}

\input{Section/Headers}
\input{Section/Index}

\setcounter{section}{1}
\begin{center}
    \textbf{\LARGE \Roman{section}. ABSTRACT}
\end{center}

\justifying
\onehalfspacing
Cresta3D is an open-source 3D game engine developed in C++ with a focus on modularity and extensibility. It leverages the OpenGL graphics API to deliver a real-time rendering pipeline and supports industry-standard file formats such as OBJ and FBX for model and animation integration. The engine architecture incorporates a scene management system, component-based entity handling, and a customizable scripting layer. Additional subsystems include an editor interface, project configuration framework, and runtime debugging tools. The project integrates and extends open-source libraries to deliver essential game engine functionality, providing a practical platform for game development and engine-level experimentation.

% Draw page border
\begin{tikzpicture}[remember picture, overlay]
    \draw[line width=1pt]
       ($(current page.north west) + (0.5in,-0.5in)$) rectangle
        ($(current page.south east) + (-0.5in,0.5in)$);
\end{tikzpicture}

\setcounter{section}{2}
\section*{\centering \Roman{section}. INTRODUCTION}
\addcontentsline{toc}{section}{INTRODUCTION}

\justifying
\onehalfspacing
Cresta3D is a lightweight, extensible game engine developed in C++ utilizing the OpenGL graphics API for rendering. Inspired by the Hazel game engine by Yan Chernikov, Cresta3D introduces a structured 3D rendering system with support for both OBJ and FBX asset pipelines, enabling developers to import static and animated models seamlessly. The engine supports a basic physics framework that provides primitive collision shapes such as box, sphere, and capsule, visualized in-editor using gizmos. It features an integrated scripting system powered by Lua, allowing runtime behavior customization without recompilation. Cresta3D is designed as a learning-oriented project, aiming to replicate core features of professional-grade engines while maintaining accessibility for students and indie developers.

\newpage
\setcounter{section}{3}
\begin{center}
    \textbf{\LARGE \Roman{section}. PROBLEM STATEMENT}
\end{center}

\justifying
\onehalfspacing
Modern game developers require a lightweight, high-performance, and modular engine that facilitates rapid development while maintaining flexibility and control. An ideal engine must support:
\begin{itemize}
  \item A real-time rendering pipeline with support for UI overlays and editor tools.
  \item A physics subsystem for simulating rigid bodies, collision detection, and dynamic interactions.
  \item A runtime scripting environment (e.g., Lua) that enables real-time behavior changes without recompilation.
  \item A robust input system capable of handling multi-device input and advanced features like mouse picking.
  \item Optimization tools for efficient handling of high-polygon 3D scenes and large asset datasets.
  \item A modular scene and entity-component system (ECS) for scalability and maintainability.
  \item An asset management system for importing, serializing, and streaming models, textures, and animations.
  \item A profiling system to analyze CPU and GPU performance bottlenecks in real time.
  \item Editor tooling support to enable in-editor manipulation of objects, cameras, lighting, and physics components.
  \item Shader system support for custom visual effects, with hot-reload capabilities.
  \item Platform abstraction layers to enable cross-platform deployment across Windows, Linux, and potentially mobile platforms.
\end{itemize}
Cresta3D is designed to fulfill these requirements by offering a customizable, developer-centric platform that combines usability with the essential features needed for robust 3D game development.

\newpage
\setcounter{section}{4}
\begin{center}
    \textbf{\LARGE \Roman{section}. FEATURES}
\end{center}

\begin{enumerate}[label={}]
    \item \textbf{4.1 Model Loading: } \\
    Cresta provides comprehensive model loading support through the Assimp (Open Asset Import Library) framework. This allows developers to import a wide variety of 3D formats such as FBX, OBJ, COLLADA, and more. The model loader processes meshes, textures, and materials, and extracts skeletal data for animated models. It also supports embedded textures within the model files, reducing external dependency issues. The loader is optimized to parse the scene hierarchy and organize vertex data into GPU-friendly formats, making rendering efficient and scalable.

    \item \textbf{4.2 Animation: } \\
    The engine includes a skeletal animation system that allows smooth real-time playback of character animations. Each model with a skeleton is processed to extract bone hierarchies, keyframes, and transformation data. Cresta performs per-frame interpolation between keyframes to ensure smooth animations. It also supports animation blending, allowing for transitions between animations like walking and running. The animation system is fully integrated with the ECS architecture, enabling component-driven animation control.

    \item \textbf{4.3 Physics System: } \\
    Powered by the Jolt Physics Engine, Cresta delivers a fast and lightweight physics simulation experience. The physics system supports dynamic and static rigid bodies, collision detection, gravity, and mass properties. Users can attach physical properties such as box, sphere, and mesh colliders to entities, allowing realistic interaction in a simulated world. The physics system is decoupled from the rendering pipeline, ensuring that logic updates and frame rendering do not interfere with each other.

    \item \textbf{4.4 Project System: } \\
    Cresta includes a flexible project management system that allows users to create and organize projects effortlessly. Each project contains its own set of assets, scenes, settings, and user-defined scripts. The system provides features like auto-saving, structured folder management, and compatibility with version control systems like Git. Projects can be opened, modified, and exported from within the editor, promoting ease of use and collaborative development.

    \item \textbf{4.5 Scene System: } \\
    Scenes in Cresta are represented as serialized graphs of entities and components. Users can create multiple scenes, load and unload them dynamically, and define hierarchical parent-child relationships among entities. The system handles scene saving/loading using efficient serialization formats such as JSON or binary blobs, ensuring fast startup and minimal file sizes. Scenes also encapsulate environmental settings like ambient light, background color, and global physics properties.

    \item \textbf{4.6 Entity Component System (ECS): } \\
    At the core of the engine lies the ECS architecture, designed for modularity and performance. Entities act as unique identifiers, while components store the actual data (like transforms, meshes, and physics bodies). Systems operate on entities that possess specific components, enabling parallel updates and cache-friendly data layouts. The ECS in Cresta allows for easy extension, letting developers define custom components and systems without touching core engine logic.

    \item \textbf{4.7 Renderer System using OpenGL: } \\
    The rendering system leverages modern OpenGL features such as shader pipelines, vertex buffer objects, framebuffer objects, and deferred rendering. It supports physically based rendering (PBR), enabling realistic materials and lighting. Dynamic lighting, shadow mapping, screen-space ambient occlusion (SSAO), and post-processing effects like bloom and HDR are integrated into the pipeline. The renderer also performs optimizations like frustum culling and level-of-detail (LOD) management to enhance performance.

    \item \textbf{4.8 Item Selection in the Editor Window: } \\
    Cresta’s editor supports real-time item selection using mouse picking. This is implemented using a color-based selection buffer where each renderable entity is assigned a unique color ID in a hidden render pass. When the user clicks in the editor viewport, the engine reads the pixel color under the mouse and maps it back to the corresponding entity. This enables precise selection and manipulation of objects, crucial for building and debugging complex scenes.

    \item \textbf{4.9 User Scripting: } \\
    User-defined scripting is enabled through Lua, a lightweight and embeddable scripting language. Scripts can be attached to entities via a ScriptComponent and are executed during runtime to control behavior such as movement, input response, AI routines, and event handling. The scripting system exposes a range of engine functions, allowing access to components, transformations, and engine events. This makes the engine highly extensible, especially for designers and developers who prefer scripting over recompiling native code.
\end{enumerate}


\justifying
\onehalfspacing

\newpage

\setcounter{section}{5}
\begin{center}
    \textbf{\LARGE \Roman{section}. ARCHITECTURE}
\end{center}

\justifying
\onehalfspacing

\subsection*{4.1. Project and Application Lifecycle}

 \includegraphics[width=1.0\textwidth]{Diagram/AllComponents.png} \\[2em]

This section describes the lifecycle and initialization sequence followed by the Cresta3D engine when launching or creating a new project.


\newpage
\justifying
\onehalfspacing

\begin{enumerate}[label={}]
    \item \textbf{I. Core Application Creation:} \\

     \includegraphics[width=0.8\textwidth]{Diagram/Core_Application.png} \\[2em]
All Cresta3D applications are built on top of a core Application class that orchestrates the initialization and management of fundamental subsystems. Among these, the Renderer plays a critical role by abstracting raw OpenGL calls into a cleaner, engine-friendly interface. It manages shader programs, buffer objects, textures, and handles batching and draw call submission, ensuring efficient rendering and minimal GPU overhead. This abstraction layer simplifies the rendering process for higher-level systems while maintaining performance.
In parallel, the Application class also integrates an ImGui overlay, which is updated each frame within the main application loop. Through ImGui, developers can inspect and modify engine state, tweak runtime parameters, view performance stats, and interact with editor tools—all without pausing the application. Input events are routed through this layer, ensuring that UI interactions coexist smoothly with the rest of the system.
By centralizing system setup and loop integration, the Application class provides a robust foundation for building flexible.
\end{enumerate}

\vspace{10em}

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}
//Application.hpp
#pragma once

#include "Core/Window.hpp"
#include "Core/Input.hpp"

#include "Core/Events/Event.hpp"
#include "Core/Events/WindowEvent.hpp"
#include "Core/Events/KeyBoardEvent.hpp"
#include "Core/Events/MouseEvent.hpp"

#include "Core/Layers/Layer.hpp"
#include "Core/Layers/LayerStack.hpp"
#include "Core/Layers/ImGUILayer.hpp"

#include "Renderer/Renderer.hpp"

#include "ECS/Scene/Scene.hpp"

#include <iostream>
#include <memory>

namespace Cresta 
{
	class Application
	{
	public:
		Application();
		virtual ~Application();

		virtual void Run();
		virtual void OnEvent(Event& e);
		
		Ref<Scene> GetActiveScene();

		void NewScene();
		void OpenScene();
		void OpenScene(const std::filesystem::path& path);
		void SaveScene();
		void SaveSceneAs();

		virtual void SaveProject(){}
		virtual void NewProject(){}
		virtual void OpenProject(){}
		virtual void OpenProject(const std::filesystem::path& path){}

		void SetSceneForLayers();

		void Init();
		void Close();
		void PushLayer(Layer* layer);
		void PushOverlay(Layer* layer);
		bool OnWindowClose(WindowCloseEvent& e);
		bool OnWindowResize(WindowResizeEvent& e);
		
		Ref<Window> GetWindow() { return p_Window; }
		static Application& GetApplication() { return *Application::sp_Instance; }

	protected:
		float p_LastFrameTime = 0.0f;
		bool p_Running;
		bool p_Minimized;
		static Ref<Scene> sp_ActiveScene;
		static Application* sp_Instance; 

		Ref<Window> p_Window;
		ImGUILayer* p_ImGUILayer;
		LayerStack p_LayerStack;
		std::filesystem::path p_ActiveScenePath;
	
	public:

		struct ProjectPath
		{
			std::string ProjectFile;
			std::filesystem::path ProjectFolder;
		};

		ProjectPath p_ActiveProjectPath;
	};

	Application* CreateApplication();
}

//Application.cpp

#include "Application.hpp"
#include "Core/Time.hpp"
#include "Platform/OpenGL/Utils.hpp"
#include "ECS/Scene/SceneSerializer.hpp"
#include "Crestaph.hpp"

namespace Cresta
{
	Application* Application::sp_Instance = nullptr;
	Ref<Scene> Application::sp_ActiveScene = nullptr;
	
	Application::Application() : p_Running(true), p_Minimized(false)
	{
		Application::sp_Instance = this;
		p_Window = Window::Create();
		p_Window->SetEventCallBack(CRESTA_BIND_EVENT_FN(Application::OnEvent));

		Log::Init();
		Renderer::Init();
		Init();
	}

	void Application::Init()
	{
		CRESTA_PROFILE_FUNCTION();
		sp_ActiveScene = CreateRef<Scene>();

		p_ImGUILayer = new ImGUILayer(sp_ActiveScene);
		PushOverlay(p_ImGUILayer);
	}

	Application::~Application()
	{
		Log::Shutdown();
		Renderer::Shutdown();
	}
	
	void Application::PushLayer(Layer* layer)
	{
		CRESTA_PROFILE_FUNCTION();

		p_LayerStack.PushLayer(layer);
		layer->OnAttach();
	}

	void Application::PushOverlay(Layer* layer)
	{
		CRESTA_PROFILE_FUNCTION();

		p_LayerStack.PushOverlay(layer);
		layer->OnAttach();
	}

	void Application::Run()
	{
		CRESTA_PROFILE_FUNCTION();
		const float fixedTimestep = 1.0f / 60.0f; 
		float accumulatedTime = 0.0f;

		int frameCount = 0;
		float fpsTimer = 0.0f;          
		float currentFPS = 0.0f;        

		int fixedUpdateCount = 0;       

		while (p_Running)
		{
			float time = RenderCommand::GetTime();	 
			float timestep = time - p_LastFrameTime; 
			p_LastFrameTime = time;
			Time::SetDeltaTime(timestep);

			accumulatedTime += timestep;
			fpsTimer += timestep;       
			frameCount++;               

			// Update FPS every second
			if (fpsTimer >= 1.0f)
			{
				CRESTA_INFO("Update Count: {0} || Fixed Update Count: {1}", frameCount, fixedUpdateCount);

				currentFPS = frameCount;           
				frameCount = 0;                    
				fpsTimer = 0.0f;                   

				//CRESTA_INFO("FPS: {0}", currentFPS);
				fixedUpdateCount = 0;
			}

			while (accumulatedTime >= fixedTimestep)
			{
				for (Layer* layer : p_LayerStack)
				{
					layer->OnFixedUpdate();
				}
				accumulatedTime -= fixedTimestep;
				fixedUpdateCount++;
			}

			p_Window->Begin();

			if (!p_Minimized)
			{
				for (Layer* layer : p_LayerStack)
				{
					layer->OnUpdate();
				}

				p_ImGUILayer->Begin();
				{
					for (Layer* layer : p_LayerStack)
					{
						layer->OnImGUIRender();
					}
				}
				p_ImGUILayer->End();
			}

			p_Window->End();
		}
	}

	void Application::OnEvent(Event& e)
	{
		EventDispatcher dispatcher(e);
		dispatcher.Dispatch<WindowCloseEvent>
        (CRESTA_BIND_EVENT_FN(Application::OnWindowClose));
		dispatcher.Dispatch<WindowResizeEvent>
        (CRESTA_BIND_EVENT_FN(Application::OnWindowResize));
		for (auto it = p_LayerStack.rbegin(); it != 
        p_LayerStack.rend(); ++it)
		{
			if (e.Handled)
				break;
			(*it)->OnEvent(e);
		}
	}

	Ref<Scene> Application::GetActiveScene()
	{
		return sp_ActiveScene;
	}

	void Application::NewScene()
	{
		sp_ActiveScene = CreateRef<Scene>();
		SetSceneForLayers();
	}

	void Application::OpenScene()
	{
		std::string filepath = Utils::FileDialogs::OpenScene("Cresta Scene (*.cresta)\0*.cresta\0");
		if (!filepath.empty())
		{
			return OpenScene(filepath);
		}
	}

	void Application::OpenScene(const std::filesystem::path& path)
	{
	
		if (path.extension().string() != ".cresta")
		{
			CRESTA_CORE_WARN("Could not load {0} - not a scene file", path.filename().string());
			return;
		}

		Ref<Scene> newScene = CreateRef<Scene>();
		if (SceneSerializer::Deserialize(*newScene ,path.string()))
		{
			//Ref<Scene> temp = sp_ActiveScene;
			sp_ActiveScene = newScene;
			p_ActiveScenePath = path;
			SetSceneForLayers();
			return;
		}

		CRESTA_CORE_WARN("Could not load {0} - not a scene file", path.filename().string());
	}

	//All the layer has a local Reference to the scene this method updates all the Layer
	void Application::SetSceneForLayers()
	{
		for (Layer* layer : p_LayerStack)
		{
			layer->SetScene(sp_ActiveScene);
		}
	}

	void Application::SaveScene()
	{
		if (!p_ActiveScenePath.empty())
		{
			sp_ActiveScene->SerializeScene(p_ActiveScenePath);
		}
		else
		{
			SaveSceneAs();
		}
	}

	void Application::SaveSceneAs()
	{
		std::string filepath = Utils::FileDialogs::SaveScene("Cresta Scene (*.cresta)\0*.cresta\0");
		if (!filepath.empty())
		{
			sp_ActiveScene->SerializeScene(filepath);
			p_ActiveScenePath = filepath;
		}
	}

	bool Application::OnWindowClose(WindowCloseEvent& e) 
	{
		p_Running = false;
		return true;
	}

	bool Application::OnWindowResize(WindowResizeEvent& e) 
	{
		if (e.GetWidth() == 0 || e.GetHeight() == 0)
		{
			p_Minimized = true;
			return false;
		}
		p_Minimized = false;
		Renderer::OnWindowResize(e.GetWidth(), e.GetHeight());
		return true;	
	}

	void Application::Close()
	{
		p_Running = false;
	}
}
\end{minted}


\newpage
\justifying
\onehalfspacing

\newpage
\justifying
\onehalfspacing

\begin{enumerate}[label={}]
    \item \textbf{II. Editor Application Setup:} \\
     \includegraphics[width=0.7\textwidth]{Diagram/Editor_Application_Loop.png} \\[2em]
    The \texttt{EditorApplication} class extends the core application to add an Editor Layer. It handles:
    \begin{itemize}
        \item Editor UI instantiation and layout configuration.
        \item Scene loading and serialization control.
        \item Input routing for tools like the editor camera and gizmo interaction.
        \item Lifecycle control, delaying the main loop until a valid project is selected.
    \end{itemize}

    \item \textbf{III. Project Handling:}
    \begin{itemize}
        \item The application loads a list of existing projects from a central project registry (e.g., \texttt{Project.json}).
        \item The user may choose to create a new project or open an existing one.
        \item On new project creation a new project directory structure is generated and Core files and configuration templates are initialized (e.g., default scene, asset folder). The path is set internally, and control passes to the Editor.
        \item On opening an existing project engine parses project metadata, which currently only include project name, path and last project opened timestamp.
    \end{itemize}
\end{enumerate}

\newpage
\justifying
\onehalfspacing

\begin{itemize}[label={}]
    \item \textbf{IV. Application Loop:} \\
    The Application loop (or game loop) is the core part of the Application that keeps the game/Engine running. It's a continuous loop that performs all the necessary updates and rendering until the game is closed. Cleanup and Exit: Handles memory cleanup before terminating the application.

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}
//Editor Application.hpp

#pragma once
#include "Core/Application.hpp"
#include "EditorLayer.hpp"
#include "Renderer/PrimitiveMeshes.hpp"

namespace Editor 
{
	class EditorApplication : public Cresta::Application 
	{
	public:
		EditorApplication()
		{
			m_EditorLayer = new EditorLayer(sp_ActiveScene);
			PushLayer(m_EditorLayer);
			Primitive::Init();
		}

		~EditorApplication() = default;

		void SaveProject() override;
		void NewProject() override;
		void OpenProject() override;
		std::string GetProjectFolder();

		void OnEvent(Event& e) override;
		void Run() override;
	private:
		EditorLayer* m_EditorLayer;
	};
}

namespace Cresta
{
	Application* CreateApplication()
	{
		return new Editor::EditorApplication();
	}
}    

//EditorApplication.cpp
#include "Crestaph.hpp"
#include "EditorApplication.hpp"
#include "Platform/OpenGL/Utils.hpp"
#include "ToastMessage.hpp"

#include <nlohmann/json.hpp>

namespace Editor
{
	namespace fs = std::filesystem;
	using json = nlohmann::json;

	struct ProjectList
	{
		uint32_t TimeStamp;
		std::string ProjectName;
		std::string ProjectPath;
	};
	
	static void ReadProjectsList(std::vector<ProjectList>& output)
	{
		std::string filePath = "assets/Projects.json";
		std::ifstream AlreadyOpenedProject(filePath);

		if (!AlreadyOpenedProject) 
		{
			// File does not exist, create it
			std::ofstream outFile(filePath);
			json j = json::object();  // Ensure it's a valid JSON object `{}` instead of `[]`
			outFile << j;
			outFile.close();

			AlreadyOpenedProject.open(filePath);  // Open the newly created file
		}

		// Check if the file is empty
		if (AlreadyOpenedProject.peek() == std::ifstream::traits_type::eof()) 
		{
			CRESTA_TRACE("File is empty, skipping parsing.");
			AlreadyOpenedProject.close();
			return;
		}

		// Now safe to parse
		json JProject;
		AlreadyOpenedProject >> JProject;

		for (json::iterator it = JProject.begin(); it != JProject.end(); ++it) 
		{
			json::iterator ProjectData = it.value().begin();
			std::string ProjectPath = ProjectData.value().get<std::string>(); // Directly get string
			++ProjectData;
			output.emplace_back(ProjectData.value().get<uint32_t>(), it.key(), ProjectPath);
		}

		AlreadyOpenedProject.close();
	}

	static void CreateOpenWindow()
	{
		ImVec4 customColor = ImVec4(0.1f, 0.1f, 0.1f, 1.0f); // RGBA
		ImVec4 previousColor = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
		ImGui::GetStyle().Colors[ImGuiCol_WindowBg] = customColor;
		bool dockSpaceOpen = true;
		ImGuiDockNodeFlags dockSpaceFlags = ImGuiDockNodeFlags_None;
		ImGuiWindowFlags windowFlags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
		ImGuiViewport* viewport = ImGui::GetMainViewport();

		ImGui::SetNextWindowPos(viewport->WorkPos);
		ImGui::SetNextWindowSize(viewport->WorkSize);
		ImGui::SetNextWindowViewport(viewport->ID);

		windowFlags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse;
		windowFlags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;

		ImGui::Begin("OpenWindow", &dockSpaceOpen, windowFlags);
		ImGui::DockSpace(ImGui::GetID("OpenWindow"), ImVec2(0.0f, 0.0f), dockSpaceFlags);
		ImGui::End();
	}

	void EditorApplication::SaveProject()
	{
		std::string filepath = Utils::FileDialogs::SaveScene("Cresta Scene (*.cproj)\0*.cproj\0");
		if (!filepath.empty())
		{
			std::ofstream save(filepath);
			save.close();
			p_ActiveProjectPath.ProjectFile = filepath.substr(filepath.find_last_of("\\")+1,filepath.length());
			p_ActiveProjectPath.ProjectFolder = filepath;
		}
	}

	void EditorApplication::NewProject()
	{
		std::string filepath = Utils::FileDialogs::GetProjectFolder();
		if (!filepath.empty())
		{
			p_ActiveProjectPath.ProjectFile = filepath.substr(filepath.find_last_of("\\") + 1, filepath.length());
			p_ActiveProjectPath.ProjectFolder = filepath;
		}
	}

	void EditorApplication::OpenProject()
	{
		std::string filepath = Utils::FileDialogs::OpenProject();
		if (!filepath.empty())
		{
			string strpath = filepath;
			p_ActiveProjectPath.ProjectFile = strpath.substr(strpath.find_last_of("\\") + 1, strpath.length());
			p_ActiveProjectPath.ProjectFolder = strpath.substr(0,strpath.find_last_of("\\"));

			std::ifstream IProjectList("assets/Projects.json");
			json j;
			IProjectList >> j;
			IProjectList.close();
			std::ofstream OProjectList("assets/Projects.json");
			j[p_ActiveProjectPath.ProjectFile] = {
				p_ActiveProjectPath.ProjectFolder,
				std::time(nullptr)
			};
			OProjectList << j;
			OProjectList.close();
		}
	}

	std::string EditorApplication::GetProjectFolder()
	{
		return Utils::FileDialogs::GetProjectFolder();
	}

	void EditorApplication::OnEvent(Event& e)
	{
		Application::OnEvent(e);
	}


	bool hasCprojFile(const std::string& folderPath) 
	{
		if (!fs::exists(folderPath) || !fs::is_directory(folderPath)) 
		{
			std::cerr << "Invalid directory: " << folderPath << std::endl;
			return false;
		}

		for (const auto& entry : fs::directory_iterator(folderPath)) 
		{
			if (entry.is_regular_file() && entry.path().extension() == ".cproj") 
			{
				return true;
			}
		}
		return false;
	}



	void EditorApplication::Run()
	{
		std::vector<ProjectList> ProjectList_;
		ReadProjectsList(ProjectList_);

		RenderCommand::SetViewport(50, 50,400,400);
		static char ProjectPath[256] = ""; // Make sure it's large enough to hold the path
		static char ProjectName[256] = ""; // Make sure it's large enough to hold the path

		bool ShowNewProjectWindow = false;
		while (p_Running)
		{
			p_ImGUILayer->Begin();
			p_Window->Begin();	

			CreateOpenWindow();

			ImGui::Begin("Projects");
			ImGui::PushStyleVar(ImGuiStyleVar_ButtonTextAlign, ImVec2(0.01,0.5)); // Increase padding

			for (ProjectList& i : ProjectList_)
			{
				if (ImGui::Button((i.ProjectName + "\n" + i.ProjectPath).c_str(), ImVec2(ImGui::GetContentRegionAvail().x, 50)))
				{
					p_ActiveProjectPath.ProjectFile = i.ProjectName;
					p_ActiveProjectPath.ProjectFolder = i.ProjectPath;
					break;
				}
			}
			ImGui::PopStyleVar();
			ImGui::End();

			ImGui::Begin("Project Options");
			if (ImGui::Button("New Project", ImVec2(ImGui::GetContentRegionAvail().x, 50)))
			{
				ShowNewProjectWindow = true;
			}
			if (ImGui::Button("Open Project",ImVec2(ImGui::GetContentRegionAvail().x, 50)))
			{
				OpenProject();
			}
			ImGui::End();			
			
			if (ShowNewProjectWindow)
			{
				ImGui::Begin("Browse");
				ImGui::InputText("Project Name", ProjectName, 50);
				ImGui::InputText("Project Path", ProjectPath, 50);
				ImGui::SameLine();
				if (ImGui::Button("Browse..."))
				{
					std::string filepath = GetProjectFolder();
					strncpy(ProjectPath, filepath.c_str(), sizeof(ProjectPath) - 1); // Copy safely
					ProjectPath[sizeof(ProjectPath) - 1] = '\0'; // Ensure null termination
				}

				if (ImGui::Button("Create", ImVec2(ImGui::GetContentRegionAvail().x / 2, 30)))
				{
					string strProjectName(ProjectName);
					string strProjectPath(ProjectPath);
					bool exits = false;
					if (!strProjectName.empty() && !strProjectPath.empty())
					{
						if (strProjectName.find(" ") != std::string::npos)
						{
							ShowToast("Project Name cannot have spaces");
						}
						else
						{
for (auto& i : ProjectList_)
{
    if (i.ProjectPath == strProjectPath)
    {
        exits = true;
    }
}

if (exits)
{
    ShowToast("Project Already Exists");
    }
							else
							{
								if (hasCprojFile(strProjectPath))
								{
									ShowToast("Folder already contains a Cresta project");
								}
								else
								{
									json j;
									std::ifstream inFile("assets/Projects.json");
									if (inFile.is_open() && inFile.peek() != std::ifstream::traits_type::eof()) 
									{
										inFile >> j;
									}
									inFile.close();

									j[strProjectName] = {
											strProjectPath,
											std::time(nullptr)
										};

									std::ofstream outFile("assets/Projects.json");
									if (outFile.is_open()) 
									{
										outFile << std::setw(4) << j << std::endl; 
									}
									outFile.close();

									std::ofstream Create(strProjectPath + "/" + strProjectName + ".cproj");
									Create.close();

									p_ActiveProjectPath.ProjectFile = strProjectName;
									p_ActiveProjectPath.ProjectFolder = strProjectPath;
									ShowNewProjectWindow = false;
								}
							}
						}
					}
					else
					{
						ShowToast("Project Name or Project Path cannot be Empty");
					}
				}
				ImGui::SameLine();
				if (ImGui::Button("Cancel", ImVec2(ImGui::GetContentRegionAvail().x, 30)))
				{
					ShowNewProjectWindow = false;
				}

				ImGui::End();
			}
			RenderToasts();
			p_ImGUILayer->End();
			p_Window->End();

			if (!p_ActiveProjectPath.ProjectFile.empty() && !p_ActiveProjectPath.ProjectFolder.empty())
			{
				Application::Run();
				break;
			}
		}
	}
}

\end{minted}
\end{itemize}

\vspace{10em}

\subsection*{4.2. Renderer Abstraction and OpenGL}
A graphics API (Application Programming Interface) is a set of tools and functions that allows developers to interact with the GPU (Graphics Processing Unit) to render 2D and 3D graphics in applications like games, simulations, or visualization software.
Cresta Uses OpenGL Cross-platform, widely used, older but still popular Graphics API.

\begin{enumerate}[label={}]
    \item \textbf{I. Renderer:} \\
    The Renderer in Cresta works in conjunction with RendererCommands. While the Renderer acts as a high-level interface that organizes and manages rendering operations, the RendererCommands handle the actual execution of low-level OpenGL commands.
    Rendering an object using a graphics API like OpenGL involves a complex sequence of method calls that must be executed in the correct order. Cresta abstracts this complexity—by encapsulating it within the Renderer and RendererCommands—so that developers working within the engine don’t need to worry about the underlying OpenGL details. This allows them to work entirely within the fully abstracted Cresta environment.
    \begin{enumerate}[label={}]
        \item \textbf{i. Model Loader:}\\
        The Model class is responsible for loading, processing, and rendering 3D models using the Assimp library. It handles complex model structures that may include multiple meshes, textures, and bones required for skeletal animations. Upon loading a model from a file path, it recursively processes the scene hierarchy to extract mesh data, including vertex positions, normals, texture coordinates, and bone weights. It manages bone information throuh a mapping system that assigns unique IDs to each bone, enabling proper animation handling. The class also caches textures to prevent redundant loading and provides functions to render the complete model using a shader. Overall, it serves as a central structure for integrating detailed and animated 3D assets into a rendering engine.

\justifying
\onehalfspacing

        \item \textbf{ii. Draw Model:}\\
        The Draw method of the Model class is responsible for rendering the entire model by iterating over all its constituent meshes. It takes a Shader object as a parameter and passes it to each mesh’s Draw function. This ensures that every mesh in the model is rendered using the specified shader program, which handles lighting, textures, and other graphical effects. The method acts as a single entry point to render the full model, abstracting away the complexity of drawing individual meshes and applying the appropriate materials and textures during rendering.
    \end{enumerate}
    
    \item \textbf{II. Renderer Principle:} \\
   The Renderer and RendererCommand classes act as abstract base classes, each declaring pure virtual methods for initializing the renderer, executing commands, and managing rendering contexts. Platform- or API-specific implementations like OpenGLRenderer inherit from these and define the actual behavior. This setup enables the engine to configure the rendering pipeline during initialization without exposing low-level API details.This interface-driven design extends to other core components—VertexBuffer, IndexBuffer, VertexArrayObject, and Framebuffer—promoting a clean abstraction layer. As a result, the engine stays API-agnostic while supporting multiple graphics backends.

   \item \textbf{III. OpenGL Implementation:}  \\
   OpenGL implementation includes Implementation of Vertex Buffer, Index Buffer, Frame Buffer, Shader, Texture, Uniform Buffer, Vertex Array Object and Input System.
   If you don't understand that read the next part carefully.\\
   Renderer module does not include implementation of the methods to use the correct Graphics API instruction set,
   so we extend the Renderer and implement the methods and during initialization we Initialize the OpenGL classes.

\item \textbf{IV. OpenGL Rendering in Cresta Game Engine}
OpenGL (Open Graphics Library) is used as the primary rendering API in the \textbf{Cresta} game engine. This section explains the key components and flow involved in the rendering process, including the Model-View-Projection (MVP) technique and perspective projection.

\item \textbf{V. OpenGL Setup and Initialization}

At the start of the rendering process, OpenGL must be initialized. This involves creating a rendering context, setting up buffers for storing vertices, and preparing shaders for execution on the GPU. In the \textbf{Cresta} engine, GLFW and GLEW are used for window management and handling OpenGL extensions, respectively.

\begin{itemize}
    \item \textbf{GLFW:} Used to create and manage windows, handle user input, and manage OpenGL contexts.
    \item \textbf{GLEW:} Used to load OpenGL extensions and functions, ensuring compatibility across different platforms and OpenGL versions.
\end{itemize}

Once the OpenGL context is created, the engine sets the viewport, clears the color buffer, and prepares the frame for rendering.

\item \textbf{VI. Shader Programs}

Shaders are small programs that run on the GPU and are responsible for rendering vertices and fragments (pixels). The \textbf{Cresta} engine uses vertex and fragment shaders to control the pipeline of vertex processing and fragment coloring.

\begin{itemize}
    \item \textbf{Vertex Shader:} Processes each vertex and passes data such as position, texture coordinates, and normals to the next stage in the pipeline.
    \item \textbf{Fragment Shader:} Responsible for calculating the final color of each pixel, taking into account lighting, textures, and other effects.
\end{itemize}

Shaders are compiled and linked into a shader program which is then used to draw objects on the screen. In the engine, the shader programs are managed and compiled dynamically based on the required material properties for each object.

\item \textbf{VII. Rendering Pipeline}

The OpenGL rendering pipeline is a sequence of stages that the engine uses to transform 3D data into a 2D image. The pipeline can be broken down into several key steps:

\begin{enumerate}
    \item \textbf{Vertex Processing:} The vertex shader processes vertices and performs transformations (like scaling, rotation, and translation) to convert them from object space to screen space.
    \item \textbf{Primitive Assembly:} The processed vertices are grouped into geometric primitives (points, lines, triangles).
    \item \textbf{Rasterization:} The geometric primitives are converted into fragments (potential pixels) on the screen.
    \item \textbf{Fragment Processing:} The fragment shader calculates the color of each pixel, taking into account factors such as lighting and texture mapping.
    \item \textbf{Final Output:} The final pixel values are written to the frame buffer and displayed on the screen.
\end{enumerate}

\item \textbf{VIII. Model-View-Projection (MVP) Technique}

The MVP technique is used to convert 3D coordinates into 2D screen space. This transformation is done through three matrices: the Model matrix, the View matrix, and the Projection matrix.
\begin{enumerate}[label={}]
\item \textbf{i. Model Matrix}

The Model matrix transforms an object’s local coordinates into world coordinates. It is responsible for scaling, rotating, and translating the model in the scene.

Where:
\item \textbf{ii. Translation}
The translation matrix moves the object in 3D space:

\[
T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\item \textbf{iii. Scaling}
The scaling matrix resizes the object:

\[
S = 
\begin{bmatrix}
s_x & 0   & 0   & 0 \\
0   & s_y & 0   & 0 \\
0   & 0   & s_z & 0 \\
0   & 0   & 0   & 1
\end{bmatrix}
\]

\item \textbf{iv. Rotation}

\subsubsection*{Rotation around X-axis}
\[
R_x(\theta) = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\theta & -\sin\theta & 0 \\
0 & \sin\theta & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\subsubsection*{Rotation around Y-axis}
\[
R_y(\theta) = 
\begin{bmatrix}
\cos\theta & 0 & \sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-\sin\theta & 0 & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

\subsubsection*{Rotation around Z-axis}
\[
R_z(\theta) = 
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\
\sin\theta & \cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\]
\\
\item \textbf{v. Combined Model Matrix}
The complete model matrix is obtained by applying the transformations in the correct order:

\[
M = T \cdot R_z \cdot R_y \cdot R_x \cdot S
\]

\item \textbf{vi. View Matrix}

The View matrix transforms the coordinates from world space to camera (view) space. It positions and orients the camera in the scene, defining the viewpoint.

Where:

The LookAt matrix is commonly used for this purpose to align the camera’s view.

\item \textbf{vii. Projection Matrix}

The Projection matrix transforms the coordinates from camera space into normalized device coordinates (NDC). In the case of perspective projection, it simulates the effects of depth and field of view.

The perspective projection matrix is defined as:

Where:

This matrix introduces a perspective effect where objects further from the camera appear smaller, and objects closer to the camera appear larger.

\item \textbf{viii. Final MVP Transformation}

The final MVP matrix is a combination of these three matrices:

This matrix is applied to each vertex in the vertex shader to transform the 3D coordinates into 2D screen coordinates.
\end{enumerate}
\end{enumerate}
\vspace{5em}

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}    
//OpenGLBuffer.hpp
#pragma once
#include "Renderer/Buffer.hpp"

namespace Cresta 
{
	class OpenGLVertexBuffer : public VertexBuffer
	{
	public:
		OpenGLVertexBuffer(uint32_t size);
		OpenGLVertexBuffer(void* vertices, uint32_t size);
		~OpenGLVertexBuffer();
		void Bind() const override;
		void Unbind() const override;
		void SetData(const void* data, uint32_t size) override;
		const BufferLayout& GetLayout() const override { return m_Layout; }
		void SetLayout(const BufferLayout& layout) override { m_Layout = layout; }
	private:
		uint32_t m_RendererID;
		BufferLayout m_Layout;
	};
	class OpenGLIndexBuffer : public IndexBuffer
	{
	public:
		OpenGLIndexBuffer(uint32_t* indices, uint32_t count);
		virtual ~OpenGLIndexBuffer();

		 void Bind() const;
		 void Unbind() const;

		uint32_t GetCount() const { return m_Count; }

	private:
		uint32_t m_RendererID;
		uint32_t m_Count;
	};
}

//OpenGLBuffer.cpp
#include "Crestaph.hpp"
#include "Platform/OpenGL/OpenGLBuffer.hpp"

#include <glad/glad.h>

namespace Cresta
{
	// VertexBuffer
	OpenGLVertexBuffer::OpenGLVertexBuffer(uint32_t size)
	{
		glGenBuffers(1, &m_RendererID);
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_DYNAMIC_DRAW);
	}
	OpenGLVertexBuffer::OpenGLVertexBuffer(void* vertices, uint32_t size)
	{
		glGenBuffers(1, &m_RendererID);
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW);
	}
	OpenGLVertexBuffer::~OpenGLVertexBuffer()
	{
		glDeleteBuffers(1, &m_RendererID);
	}
	void OpenGLVertexBuffer::Bind() const
	{
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
	}
	void OpenGLVertexBuffer::Unbind() const
	{
		glBindBuffer(GL_ARRAY_BUFFER, 0);
	}
	void OpenGLVertexBuffer::SetData(const void* data, uint32_t size)
	{
		glBindBuffer(GL_ARRAY_BUFFER, m_RendererID);
		glBufferSubData(GL_ARRAY_BUFFER, 0, size, data);
	}
// IndexBuffer 
OpenGLIndexBuffer::OpenGLIndexBuffer(uint32_t* indices, uint32_t count)
		: m_Count(count)
	{
		glGenBuffers(1, &m_RendererID);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(uint32_t), indices, GL_STATIC_DRAW);
	}
	OpenGLIndexBuffer::~OpenGLIndexBuffer()
	{
		glDeleteBuffers(1, &m_RendererID);
	}
	void OpenGLIndexBuffer::Bind() const
	{
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);
	}
	void OpenGLIndexBuffer::Unbind() const
	{
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	}
}
\end{minted}

\newpage

\justifying
\onehalfspacing

\subsection*{4.3. Profiler}

 \includegraphics[width=1.0\textwidth]{Diagram/Flowcharts.png} \\[2em]

\begin{enumerate}[label={}]
    \item \textbf{I. Bench Marker:} \\
    The BenchMarker class is a singleton profiler that manages performance logging in Chrome Tracing-compatible JSON format. It starts a profiling session with BeginSession(), opening a file and writing a JSON header. During execution, WriteProfile() logs profiling data—such as function name, duration, thread ID, and start time—into the file. EndSession() finalizes the session by writing a footer and cleaning up resources. If a session is already active, it’s properly closed before starting a new one. The class ensures clean, structured profiling output for performance analysis.
\end{enumerate}


\newpage

\begin{enumerate}[label={}]
\item \textbf{II. Instrumentation Timer:} \\
   The InstrumentationTimer is a lightweight RAII-based(Resource Acquisition Is Initialization) utility that measures the duration of a scoped code block. When created, it records the start time using a high-resolution clock. Upon destruction—or when Stop() is manually called—it calculates the elapsed time and sends the profiling data (name, duration, thread ID, and start timestamp) to the BenchMarker via WriteProfile(). This allows automatic and precise timing of functions or scopes with minimal code and ensures the data is logged even if the scope exits unexpectedly.
\end{enumerate}

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}
//Profiler.hpp

    #pragma once
#include "Crestaph.hpp"

namespace Cresta
{
	namespace Profiler
	{
		using FloatingPointMicroseconds = std::chrono::duration<double, std::micro>;

		struct ProfileResult
		{
			std::string Name;

			FloatingPointMicroseconds Start;
			std::chrono::microseconds ElapsedTime;
			std::thread::id ThreadID;
		};

		struct InstrumentationSession
		{
			std::string Name;
			
			InstrumentationSession(std::string name) : Name(name)
			{}

			~InstrumentationSession()
			{
			}
		};

		class BenchMarker
		{
		public:
			BenchMarker();
			~BenchMarker();
			BenchMarker(const BenchMarker&) = delete;
			BenchMarker(BenchMarker&&) = delete;

			void BeginSession(const std::string& name, const std::string& filepath = "C:\\dev\\Cresta\\results.json");
			void EndSession();
			void WriteProfile(const ProfileResult& result);
			static BenchMarker& Get();

			void WriteHeader();
			void WriteFooter();
			void InternalEndSession();

		private:
			static BenchMarker* sm_Instance;
			InstrumentationSession* m_CurrentSession;
			std::ofstream m_OutputStream;
		};

		template <size_t N>
		struct ChangeResult
		{
			char Data[N];
		};

		class InstrumentationTimer
		{
		public:
			InstrumentationTimer(const char* name)
				: m_Name(name), m_Stopped(false)
			{
				m_StartTimepoint = std::chrono::steady_clock::now();
			}

			~InstrumentationTimer()
			{
				if (!m_Stopped)
				{
					Stop();
				}
			}

			void Stop()
			{
				auto endTimepoint = 
                std::chrono::steady_clock::now();
				auto highResStart = FloatingPointMicroseconds{ 
                m_StartTimepoint.time_since_epoch() };
				auto elapsedTime = 
std::chrono::time_point_cast<std::chrono::microseconds>
(endTimepoint).time_since_epoch() - 
std::chrono::time_point_cast<std::chrono::microseconds>
(m_StartTimepoint).time_since_epoch();

				BenchMarker::Get().WriteProfile({ m_Name, highResStart, elapsedTime, std::this_thread::get_id() });

				m_Stopped = true;
			}
		private:
			const char* m_Name;
			std::chrono::time_point<std::chrono::steady_clock> m_StartTimepoint;
			bool m_Stopped;
		};

		template <size_t N, size_t K>
		constexpr auto CleanupOutputString(const char(&expr)[N], const char(&remove)[K])
		{
			ChangeResult<N> result = {};

			size_t srcIndex = 0;
			size_t dstIndex = 0;
			while (srcIndex < N)
			{
				size_t matchIndex = 0;
				while (matchIndex < K - 1 && srcIndex + matchIndex < N - 1 && expr[srcIndex + matchIndex] == remove[matchIndex])
				{
					matchIndex++;
				}

				if (matchIndex == K - 1)
				{
					srcIndex += matchIndex;
				}
				result.Data[dstIndex++] = expr[srcIndex] == '"' ? '\'' : expr[srcIndex];
				srcIndex++;
			}
			return result;
		}
	}
}

#define CRESTA_PROFILE 1
#if CRESTA_PROFILE 
#define CRESTA_PROFILE_BEGIN_SESSION(name, filepath) ::Cresta::Profiler::BenchMarker::Get().BeginSession(name, filepath)
#define CRESTA_PROFILE_END_SESSION() ::Cresta::Profiler::BenchMarker::Get().EndSession()
#define CRESTA_PROFILE_SCOPE_LINE2(name, line) constexpr auto fixedName##line = ::Cresta::Profiler::CleanupOutputString(name, "__cdecl ");\
											   ::Cresta::Profiler::InstrumentationTimer timer##line(fixedName##line.Data)
#define CRESTA_PROFILE_FUNCTION() CRESTA_PROFILE_SCOPE_LINE2(__FUNCSIG__, __LINE__)
#else
#define CRESTA_PROFILE_BEGIN_SESSION(name, filepath)
#define CRESTA_PROFILE_END_SESSION()
#define CRESTA_PROFILE_SCOPE_LINE2(name, line)
#define CRESTA_PROFILE_FUNCTION()
#endif

//Profiler.cpp
#include "Profiler.hpp"

#include <mutex>

namespace Cresta
{
	namespace Profiler
	{
		BenchMarker* BenchMarker::sm_Instance = nullptr;

		void BenchMarker::BeginSession(const std::string& name, const std::string& filepath)
		{
			if (m_CurrentSession)
			{
				// If there is already a current session, then close it before beginning new one.
				// Subsequent profiling output meant for the original session will end up in the
				// newly opened session instead.  That's better than having badly formatted
				// profiling output.
				if (Log::GetCoreLogger()) // Edge case: BeginSession() might be before Log::Init()
				{
					CRESTA_CORE_INFO("Instrumentor::BeginSession('{0}') when session '{1}' already open.", name, m_CurrentSession->Name);
				}
				InternalEndSession();
			}

			m_OutputStream.open(filepath);

			if (m_OutputStream.is_open())
			{
				m_CurrentSession = new InstrumentationSession(name);
				WriteHeader();
			}
			else
			{
				if (Log::GetCoreLogger()) // Edge case: BeginSession() might be before Log::Init()
				{
					CRESTA_CORE_INFO("Instrumentor could not open results file '{0}'.", filepath);
				}
			}
		}

		void BenchMarker::EndSession()
		{
			InternalEndSession();
		}

		void BenchMarker::WriteProfile(const ProfileResult& result)
		{
			std::stringstream json;

			json << std::setprecision(3) << std::fixed;
			json << ",{";
			json << "\"cat\":\"function\",";
			json << "\"dur\":" << (result.ElapsedTime.count()) << ',';
			json << "\"name\":\"" << result.Name << "\",";
			json << "\"ph\":\"X\",";
			json << "\"pid\":0,";
			json << "\"tid\":" << result.ThreadID << ",";
			json << "\"ts\":" << result.Start.count();
			json << "}";

			if (m_CurrentSession)
			{
				m_OutputStream << json.str();
				m_OutputStream.flush();
			}
		}

		BenchMarker& BenchMarker::Get()
		{
			if (sm_Instance)
			{
				return *sm_Instance;
			}
			static BenchMarker instance;
			sm_Instance = &instance;
			return instance;
		}

		BenchMarker::BenchMarker()
		{

		}

		BenchMarker::~BenchMarker()
		{
			EndSession();
		}

		void BenchMarker::WriteHeader()
		{
			m_OutputStream << "{\"otherData\": {},\"traceEvents\":[{}";
			m_OutputStream.flush();
		}

		void BenchMarker::WriteFooter()
		{
			m_OutputStream << "]}";
			m_OutputStream.flush();
		}

		void BenchMarker::InternalEndSession()
		{
			if (m_CurrentSession)
			{
				WriteFooter();
				m_OutputStream.close();
				delete m_CurrentSession;
				m_CurrentSession = nullptr;
			}
		}
	}
}

\end{minted}


\subsection*{4.4. Scene \& ECS}

 \includegraphics[width=0.9\textwidth]{Diagram/ECS.png} \\[2em]
\begin{enumerate}[label={}]
    \item \textbf{I. Scene:} \\
    The Scene class in Cresta acts as the central manager for all game entities and their behaviors. It encapsulates an entt::registry, which is the backbone of the Entity Component System (ECS) architecture, allowing efficient management of entities and their associated components. The class provides utility functions to create, duplicate, find, and destroy entities using names or UUIDs. It supports physics integration by interfacing with physics-related operations like assigning rigid bodies or colliders. Additionally, it handles scene rendering aspects such as drawing the skybox and serializing scene data to disk.   
\end{enumerate}

\begin{enumerate}[label={}]
    \item \textbf{II. ECS:} \\
    ECS (Entity-Component-System) is a software architectural pattern commonly used in game engines and simulations to organize complex systems efficiently and flexibly. It breaks down into three core parts:
    \begin{itemize}
    \item \textbf{Entity:} \\
    An Entity is a general-purpose object that acts as a unique ID or placeholder. It doesn’t contain data or logic by itself—it simply represents  "something" in the game (like a player, light, or bullet).
    \item \textbf{Component:} \\
    A Component is a simple data structure that holds data and logic. Each  component represents a specific aspect or feature of an entity. For example: Transform Component(position, rotation, scale), Mesh, Camera Component
    By combining components, you define the behavior and characteristics of an  entity.
    \item \textbf{System:} \\
    A System contains the logic that operates on entities with a specific set of components. It iterates over all matching entities and applies behavior to them. For instance:
    A Physics System might update all entities with Rigid Body Component and transform Component.
    A Render System might draw all entities with Mesh Renderer Component.
    \end{itemize}

    \item \textbf{III. Life Cycle Methods:} \\
    In the Cresta game engine, the ECS architecture is enhanced with a structured life cycle system that allows components to define specific behaviors at different stages of the game loop. Each entity can register components that optionally implement key life cycle methods such as OnStart, OnUpdate, OnFixedUpdate, OnRender, and OnEnd. These methods are automatically detected and stored as callable functions when a component is added to an entity.
\begin{itemize}
    \item \textbf{OnStart:} Called at the start of play mode   
    \item \textbf{OnUpdate:} called at every frame of the play mode
    \item \textbf{OnRender:} called at every frame (both play and normal mode).
    \item \textbf{OnFixedUpdate:} called at Fixed duration during play mode.
    \item \textbf{OnEnd:} called at the End of play mode.
\end{itemize}
\end{enumerate}

\newpage
\begin{itemize}[label={}]
    \item \textbf{IV. Components:}
    \begin{itemize}[label={}]
        \item \textbf{i. ID Component:}
        ID component uses the UUID class which creates a random integer of 64 bits size (uint64\_t) which acts as a unique Identifier for each Entity.
        This ID used by Model render, Physics System and other modules to keep track of individual entity and maintain a relation between UUID and local identifier.
        For example: Physics System maintains a map to maintain the list of created physics bodies and the UUID to identify them. 
        \item \textbf{ii. Tag Component:}
        This is just string identifier for a entity which is not unique to the entity.
        \item \textbf{Transform:}
        Transform Component is responsible for creating and maintaining data related to Position, Rotation and Scale of the Entity, also inform other component about the change in the data that rely on the transform component for their function.  
        \item \textbf{iii. Renderer Components:}
        Render Components are category of components who's primary objective is to render an object on to the screen. This does not include components which render Gizmos or object as secondary functions(eg. BoxCollider).
        \begin{itemize}[label={}]
            \item \textbf{(a) Mesh Renderer:}
            This Component uses the Model class of the Renderer to load model file such as obj or fbx and provide the functionality to render this model onto the screen, nothing else.
            \item \textbf{(b) Sprite Renderer:}
            Sprite Renderer lets you render a texture onto the screen and lets you modify texture properties, such as texture size, rgb values.   
        \end{itemize}
        \item \textbf{iv. Physics Components:}
        \begin{itemize}[label={}]
            \item \textbf{(a) Rigid Body:}
            Rigid Body component lets the entity be effected by Gravity.
            \item \textbf{(b) Box Collider:}
            This provides collision detection to a entity with a box around it, and also lets it act as a trigger.
            Box Collider Component lets you edit the rotation and scale of the box collider with the entity center position as the box collider center position.
            \item \textbf{(c) Sphere Collider:}
            Sphere Collider add the collision option with sphere shape.
            \item \textbf{(d) Capsule Collider:}
            Capsule Collider add the collision option with Capsule shape.
        \end{itemize}
    \end{itemize}
\end{itemize}

\newpage
    \begin{itemize}[label={}]
        \item \textbf{v. Script:}
        Script component Lets the user add the custom user script to the an Entity in the Scene.
        \begin{itemize}[label={}]
            \item \textbf{(a) User Scripting using Lua:}\\
            User scripting using Lua is important because it allows developers to expose flexible, high-level control to users without compromising the core engine's stability or performance. Lua’s lightweight nature and fast execution make it ideal for embedding in game engines, applications, and simulation environments. By enabling user scripting, developers empower users or designers to create custom behaviors, automate tasks, and extend functionality without modifying the source code. This not only speeds up development but also encourages modularity and creativity, making applications more dynamic and adaptable to varied use cases.
            \item \textbf{(b) Sol3:}\\
            Sol3 is a modern and powerful C++ library that provides seamless integration between C++ and the Lua scripting language. It simplifies the process of binding Lua scripts to C++ code by offering an easy-to-use, header-only interface that handles complex data conversions, function calls, and object management. Sol3 leverages advanced C++ features like templates and smart pointers to ensure safety, flexibility, and performance. It is widely used in game engines and software projects where scripting is essential, allowing developers to expose C++ classes, functions, and variables to Lua with minimal boilerplate code.
        \end{itemize}
    \end{itemize}
    \begin{itemize}[label={}]
        \item \textbf{VI. Animator:}
        \begin{itemize}[label={}]
            \item \textbf{i. Animator:}
            The 'Animator' class in the Cresta engine is responsible for handling skeletal animations by updating bone transformations over time. It interfaces with the `Animation` class to manage and play animation sequences, calculating bone matrices based on a hierarchical node structure (`AssimpNodeData`) typically loaded through the Assimp library. The animator maintains a vector of final bone matrices used for GPU skinning and supports switching between different animations. It includes multithreading support with a dedicated animation thread and synchronization primitives like mutexes and condition variables to ensure smooth, real-time animation playback. The class offers functionality to start, end, and reset animations, and encapsulates timing controls using 'm\_CurrentTime', 'm\_DeltaTime', and a public 'timestep' for fine-grained control over animation speed.
            \vspace*{3em}
            \item \textbf{ii. Animation:}
            The `Animation` class in the Cresta engine is responsible for loading and managing skeletal animation data from external files using the Assimp library. It stores essential information such as animation duration, ticks per second, and a list of bones involved in the animation. The class also constructs a hierarchical node structure (`AssimpNodeData`) that mirrors the bone hierarchy of the model, allowing for recursive transformation calculations during animation playback. Through the `SetAnimation` function or constructor, it parses the animation file and populates the bone and node data by reading missing bones and traversing the scene hierarchy. The class provides convenient access to the root node, bone map, and other metadata, and supports searching for specific bones by name—critical for applying animations accurately during runtime.

        \item \textbf{iii. Animation Bones:}
        The `Bone` class in the Cresta engine encapsulates the animation data and transformation logic for a single bone in a skeletal animation system. Each `Bone` instance holds its name, a unique ID, and keyframe data for position (`KeyPosition`), rotation (`KeyRotation`), and scale (`KeyScale`) extracted from the corresponding `aiNodeAnim` channel provided by Assimp. The `Update` method calculates the bone’s local transformation matrix for a given animation time by interpolating between keyframes, ensuring smooth transitions during playback. Internally, it uses helper functions to determine the correct keyframe indices and compute interpolation factors, enabling accurate blending of transformations over time. The class provides access to the bone's name, ID, and computed local transformation, which are crucial for constructing the final matrix hierarchy used in skeletal animation. Overall, it plays a vital role in enabling per-bone animation blending and motion within the larger animation system.

 \includegraphics[width=0.9\textwidth]{Diagram/Animator.png} \\[2em]
        \vspace{2em}
        \end{itemize}

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}
#pragma once
#include "Crestaph.hpp"
#include "Renderer/Camera.hpp"
#include "Renderer/Model.hpp"
#include "Renderer/Texture.hpp"
#include "ECS/UUID.hpp"
#include "Core/Physics/PhysicsUtils.hpp"

#include <exception>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <Jolt/Physics/Body/BodyID.h>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/quaternion.hpp>

namespace Cresta 
{
	class Dispatcher
	{
	public:		
		void Subscribe(const std::string& key, std::function<void(bool)> function)
		{
			Observers[key] = function;
		}

		void UnSubscribe(const std::string& key)
		{
			Observers.erase(key);
		}

		void post(bool value) const
		{
			for (auto& observer : Observers)
			{
				observer.second(value);
			}
		}

	private:
		std::map<std::string, std::function<void(bool)>> Observers;
	};

	// Helper to check if a class overrides OnStart
	template <typename Base, typename Derived, typename = void>
	struct has_overridden_OnStart : std::false_type {}; // Defaults to false if OnUpdate doesn't exist

	template <typename Base, typename Derived>
	struct has_overridden_OnStart <Base, Derived, std::void_t<decltype(&Base::OnStart), decltype(&Derived::OnStart)>> {
		static constexpr bool value = !std::is_same_v<decltype(&Base::OnStart), decltype(&Derived::OnStart)>;
	};

	// Helper to check if a class overrides OnRender
	template <typename Base, typename Derived, typename = void>
	struct has_overridden_OnRender : std::false_type {}; // Defaults to false if OnUpdate doesn't exist

	template <typename Base, typename Derived>
	struct has_overridden_OnRender<Base, Derived, std::void_t<decltype(&Base::OnRender), decltype(&Derived::OnRender)>> {
		static constexpr bool value = !std::is_same_v<decltype(&Base::OnRender), decltype(&Derived::OnRender)>;
	};

	// Helper to check if a class overrides OnUpdate
	template <typename Base, typename Derived, typename = void>
	struct has_overridden_OnUpdate : std::false_type {}; // Defaults to false if OnUpdate doesn't exist

	template <typename Base, typename Derived>
	struct has_overridden_OnUpdate<Base, Derived, std::void_t<decltype(&Base::OnUpdate), decltype(&Derived::OnUpdate)>> {
		static constexpr bool value = !std::is_same_v<decltype(&Base::OnUpdate), decltype(&Derived::OnUpdate)>;
	};

	// Helper to check if a class overrides OnFixedUpdate
	template <typename Base, typename Derived, typename = void>
	struct has_overridden_OnFixedUpdate : std::false_type {}; // Defaults to false if OnFixedUpdate doesn't exist

	template <typename Base, typename Derived>
	struct has_overridden_OnFixedUpdate<Base, Derived, std::void_t<decltype(&Base::OnFixedUpdate), decltype(&Derived::OnFixedUpdate)>> {
		static constexpr bool value = !std::is_same_v<decltype(&Base::OnFixedUpdate), decltype(&Derived::OnFixedUpdate)>;
	};

	// Helper to check if a class overrides OnEnd
	template <typename Base, typename Derived, typename = void>
	struct has_overridden_OnEnd : std::false_type {}; // Defaults to false if OnUpdate doesn't exist

	template <typename Base, typename Derived>
	struct has_overridden_OnEnd <Base, Derived, std::void_t<decltype(&Base::OnEnd), decltype(&Derived::OnEnd)>> {
		static constexpr bool value = !std::is_same_v<decltype(&Base::OnEnd), decltype(&Derived::OnEnd)>;
	};

	class Entity;

	class ComponentTemplate 
	{
	public:
		explicit ComponentTemplate(Entity* entity) : p_Entity(entity) {}
		virtual ~ComponentTemplate() = default;

		ComponentTemplate(ComponentTemplate&& other) noexcept : p_Entity(std::exchange(other.p_Entity, nullptr)) {}
		ComponentTemplate& operator=(ComponentTemplate&& other) noexcept {
			if (this != &other) {
				p_Entity = std::exchange(other.p_Entity, nullptr);
			}
			return *this;
		}

		virtual void UI() = 0;
		virtual void OnStart() {}
		virtual void OnRender() {}
		virtual void OnUpdate() {}
		virtual void OnFixedUpdate() {}
		virtual void OnEnd() {}
		virtual void OnGizmo() {}
		virtual void OnComponentAdded() {}
		virtual void OnComponentRemoved() {}
		virtual std::string ToString() = 0;

		Entity* GetEntity() { return p_Entity; }
		const Entity* GetEntity() const { return p_Entity; }

	protected:
		Entity* p_Entity;
	};

	class IDComponent
	{
	private:
		UUID m_ID;
	public:
		IDComponent()
		{
			std::cout << "Default Construct\n";
		}
		IDComponent(Entity* entity) 
		{ 
		}
		IDComponent(Entity* entity, uint64_t ID) : m_ID(ID)	
		{
		}

		void OnComponentAdded();
		void OnComponentRemoved();

		inline const UUID& GetUUID() const { 
			return m_ID; 
		}
		std::string ToString()
		{
			return "IDComponent";
		}
	};

	class TagComponent : public ComponentTemplate
	{
	public:
		std::string Tag;
		TagComponent(Entity* entity, const std::string& tag) : ComponentTemplate(entity),Tag(tag) {}

		void UI() override {}
		void OnComponentAdded() override;
		void OnComponentRemoved() override;
		std::string ToString() override
		{
			return "Tag Component";
		}
	};

	class TransformWrapper;

	class Transform : public ComponentTemplate 
	{
	public:
		Transform(Entity* entity) : ComponentTemplate(entity) {}

		inline void SetPosition(const glm::vec3& Position)		{ m_Translation = Position;	OnValidate.post(false);	}
		inline void SetScale(const glm::vec3& Scale)			{ m_Scale = Scale;			OnValidate.post(false);	}
		inline void SetRotation(const glm::quat& rotation)		
		{
			m_Rotation = rotation;	
			this->rotation = glm::degrees(glm::eulerAngles(m_Rotation));
			
			OnValidate.post(false);	
		}

		inline constexpr glm::vec3& GetPosition() const { return *(new glm::vec3(m_Translation)); }
		inline constexpr glm::quat& GetRotation() const { return *(new glm::quat(m_Rotation));	}
		inline constexpr glm::vec3& GetScale()	  const { return *(new glm::vec3(m_Scale));		}

		glm::mat4 GetTransform() const
		{
			return glm::translate(glm::mat4(1.0f), m_Translation)
				* glm::toMat4(m_Rotation)
				* glm::scale(glm::mat4(1.0f), m_Scale);
		}

		std::string ToString() override { return "Transform Component"; }

		void UI() override;
		void OnComponentAdded() override;
		void OnComponentRemoved() override;

	private:
		inline void PhysicsSetPosition(const glm::vec3& Position) { m_Translation = Position;	OnValidate.post(true); }
		inline void PhysicsSetScale(const glm::vec3& Scale) { m_Scale = Scale;			OnValidate.post(true); }
		inline void PhysicsSetRotation(const glm::quat& rotation)
		{
			m_Rotation = rotation;
			this->rotation = glm::degrees(glm::eulerAngles(m_Rotation));

			OnValidate.post(true);
		}

	private:
		glm::vec3 m_Translation = { 0.0f, 0.0f, 0.0f };
		glm::vec3 rotation = { 0.0f,0.0f, 0.0f };
		glm::quat m_Rotation = { 1.0f, 0.0f, 0.0f, 0.0f };
		glm::vec3 m_Scale = { 1.0f, 1.0f, 1.0f };
	public:
		Dispatcher OnValidate;

		friend class TransformWrapper;
	};

	class CameraComponent : public ComponentTemplate
	{
	public:
		CameraComponent(Entity* entity) : ComponentTemplate(entity) {}

		Camera Camera;
		bool Primary = true; // TODO: think about moving to Scene
		bool FixedAspectRatio = false;


		std::string ToString() override
		{
			return "Camera Component";
		}

		void UI() override {}
		void OnComponentAdded() override;
		void OnComponentRemoved() override;
	};
}   
\end{minted}
        
        \item \textbf{VII. Physics}
        \begin{itemize}[label={}]
            \item \textbf{i. Physics Class \& Controller: }
            \begin{enumerate}
            \item \textbf{Physics Class:}
            The `Physics` class in the Cresta engine serves as a high-level static interface for managing physical simulation, leveraging the Jolt Physics engine under the hood. It acts as a wrapper around the `PhysicsController`, which handles the actual logic for creating, updating, and managing physical bodies and their interactions in the scene. Through this interface, developers can easily add rigid bodies, attach colliders, set transformations, adjust physical properties like gravity and scale, and toggle trigger states for entities identified by their UUIDs. The class also allows querying and modifying entity positions and rotations in the physics world, enabling tight integration between game logic and physics simulation. With built-in support for starting, stopping, and stepping the simulation, the `Physics` class plays a crucial role in enabling dynamic, real-time interactions in the engine while maintaining modularity and encapsulation.
            \item \textbf{Physics Contorller:}
            The `PhysicsController` class in the "Cresta" engine is a core component responsible for managing and interfacing with the Jolt Physics System. It provides high-level functionality to create, configure, and manipulate physics bodies associated with entities identified by UUIDs. This class handles adding and removing colliders, switching between static and dynamic motion types, setting physical properties such as gravity, position, rotation, and scale, and managing sensor states (triggers). It encapsulates internal Jolt components like the physics system, job system, allocators, and body interface, and implements broadphase filtering and body activation/contact listening. The controller initializes the physics system, maintains a mapping between entities and their corresponding `BodyID`s, and includes debug tools like tracing and assert handling. Additionally, it defines key constants for physics simulation and supports runtime manipulation of physics bodies, making it a vital part of entity-physics integration in the engine.
            \end{enumerate}
        \end{itemize}
    \end{itemize}

\newpage

\begin{minted}[linenos, breaklines=true, tabsize = 1]{c++}
//Physics.hpp
#pragma once
#include "PhysicsController.hpp"

// Member variable to store the initial state
using namespace JPH;
using namespace JPH::literals;

namespace Cresta
{
	class Scene;

	class Physics
	{
	public:
		static void ClearBodies();
		static void MakeBodyStatic(const UUID& EntityID);
		static void CreateBody(const UUID& EntityID);

		static void AddRigidBody(const UUID& EntityID);
		static void AddCollider(const UUID& EntityID,const ColliderShape& shape);
		static void SetColliderTrigger(const UUID& EntityID,bool IsTrigger);
		static void RemoveCollider(const UUID& EntityID);
		
		static glm::vec3 GetBodyPosition(const UUID& EntityID);
		static glm::quat GetBodyRotation(const UUID& EntityID);
		
		static void SetBodyPosition(const UUID& EntityID, const glm::vec3& position);
		static void SetBodyRotation(const UUID& EntityID, const glm::quat& rotation);

		static void SetGravityFactor(const UUID& EntityID, float gravityfactor);

		static void SetBodyShapeOffset(const UUID& EntityID, const glm::vec3& scale);
		static void SetBodyRadius(const UUID& EntityID, const float radius);
		static void SetBodyShapeScale(const UUID& EntityID, const glm::vec3& scale);

	private:
		static void Step();
		static void Start();
		static void Stop();

	private:
		static Scope<PhysicsController> sm_PhysicsController;
		friend class Scene;
	};
}

//Physics.cpp
#include "Physics.hpp"
#include "Physics.hpp"
#include <Jolt/Physics/Collision/Shape/ScaledShape.h>
#include <Jolt/Physics/Body/BodyCreationSettings.h>

namespace Cresta
{
	Scope<PhysicsController> Physics::sm_PhysicsController = CreateScope<PhysicsController>();

	void Physics::ClearBodies()
	{
		sm_PhysicsController->ClearBodies();
	}

	void Physics::MakeBodyStatic(const UUID& EntityID)
	{
		sm_PhysicsController->MakeBodyStatic(EntityID);
	}

	void Physics::CreateBody(const UUID& EntityID)
	{
		sm_PhysicsController->CreateBody(EntityID);
	}

	void Physics::AddRigidBody(const UUID& EntityID)
	{
		sm_PhysicsController->AddRigidBody(EntityID);
	}

	void Physics::RemoveCollider(const UUID& EntityID)
	{
		sm_PhysicsController->RemoveCollider(EntityID);
	}

	void Physics::AddCollider(const UUID& EntityID, const ColliderShape& shape)
	{
		sm_PhysicsController->AddCollider(EntityID, shape);
	}

	void Physics::SetColliderTrigger(const UUID& EntityID, bool IsTrigger)
	{
		sm_PhysicsController->SetColliderTrigger(EntityID,IsTrigger);
	}

	void Physics::SetBodyPosition(const UUID& EntityID, const glm::vec3& position)
	{
		sm_PhysicsController->SetBodyPosition(EntityID, position);
	}

	void Physics::SetBodyShapeOffset(const UUID& EntityID, const glm::vec3& scale)
	{
		sm_PhysicsController->SetBodyShapeOffset(EntityID, scale);
	}

	void Physics::SetBodyRadius(const UUID& EntityID, const float radius)
	{
		sm_PhysicsController->SetBodyShapeRadius(EntityID, radius);
	}

	void Physics::SetBodyShapeScale(const UUID& EntityID, const glm::vec3& scale)
	{
		sm_PhysicsController->SetBodyShapeScale(EntityID, scale);
	}

	glm::quat Physics::GetBodyRotation(const UUID& EntityID)
	{
		return sm_PhysicsController->GetBodyRotation(EntityID);
	}

	void Physics::SetBodyRotation(const UUID& EntityID, const glm::quat& rotation)
	{
		sm_PhysicsController->SetBodyRotation(EntityID, rotation);
	}

	void Physics::SetGravityFactor(const UUID& EntityID, float gravityfactor)
	{
		sm_PhysicsController->SetGravityFactor(EntityID, gravityfactor);
	}

	glm::vec3 Physics::GetBodyPosition(const UUID& EntityID)
	{
		return sm_PhysicsController->GetBodyPosition(EntityID);
	}

	void Physics::Step()
	{	
		sm_PhysicsController->Step();
	}

	void Physics::Start()
	{
		sm_PhysicsController->Start();
	}

	void Cresta::Physics::Stop()
	{
		sm_PhysicsController->Stop();
	}
}

//PhysicsController.hpp
#pragma once
#include "Crestaph.hpp"
#include "PhysicsUtils.hpp"
#include "entt/entt.hpp"
#include "ECS/UUID.hpp"

#include <Jolt/Physics/StateRecorder.h>
#include <Jolt/Physics/StateRecorderImpl.h>


// Member variable to store the initial state
using namespace JPH;
using namespace JPH::literals;

namespace Cresta
{
	class Physics;

	class PhysicsController
	{
	public:
		static void TraceImpl(const char* inFMT, ...);

#ifdef JPH_ENABLE_ASSERTS
		// Callback for asserts, connect this to your own assert handler if you have one
		static bool AssertFailedImpl(const char* inExpression, const char* inMessage, const char* inFile, uint inLine);
#endif // JPH_ENABLE_ASSERTS

		PhysicsController();
		~PhysicsController();

		void ClearBodies();

		void MakeBodyStatic(const UUID& EntityID);

		void RemoveCollider(const UUID& EntityID);

		void AddRigidBody(const UUID& EntityID);

		void CreateBody(const UUID& EntityID);
		void AddCollider(const UUID& EntityID, const ColliderShape& shape);
		void SetColliderTrigger(const UUID& EntityID,bool IsTrigger);

		glm::vec3 GetBodyPosition(const UUID& EntityID);
		glm::quat GetBodyRotation(const UUID& EntityID);

		void SetCapsuleHeightRadius(const UUID& EntityID,float HalfHeight, float Radius);

		void SetBodyPosition(const UUID& EntityID, const glm::vec3& position);
		void SetBodyShapeOffset(const UUID& EntityID, const glm::vec3& CenterOfMass);
		void SetBodyShapeRadius(const UUID& EntityID, float radius);
		void SetBodyRotation(const UUID& EntityID, const glm::quat& rotation);
		void SetBodyShapeScale(const UUID& EntityID, const glm::vec3& scale);

		void SetGravityFactor(const UUID& EntityID, float gravityfactor );

		void Step();
		void Start();
		void Stop();

	public:
		RVec3 position;
		Vec3 velocity;

	private:
		void Init();

	private:
		// Constants for physics simulation
		static constexpr uint cm_NumBodies = 10240;
		static constexpr uint cm_NumBodyMutexes = 0; // Auto-detect
		static constexpr uint cm_MaxBodyPairs = 65536;
		static constexpr uint cm_MaxContactConstraints = 20480;

		const RVec3 cm_Position = RVec3(0.0_r, 0.0_r, 0.0_r);
		const RVec3 cm_HalfExtents = RVec3(1.0f, 1.0f, 1.0f);

		const Quat cm_IdentityRotation = Quat::sIdentity();

		const float cm_CapsuleHalfHeight = 1.0f; // Half the distance between the hemispherical ends
		const float cm_Radius = 0.5f;     // Radius of the capsule
		const float cm_DeltaTime = 1.0f / 60.0f;

		// Jolt components

		StateRecorderImpl m_InitialStateRecorder;

		Scope<JobSystem> m_JobSystem;
		Scope<TempAllocator> m_TempAllocator;
		PhysicsSystem m_PhysicsSystem;

		BodyInterface* m_BodyInterface;

		// Broadphase filters
		BPLayerInterfaceImpl m_BroadPhaseLayerInterface;
		ObjectLayerPairFilterImpl m_ObjectVsObjectLayerFilter;
		ObjectVsBroadPhaseLayerFilterImpl m_ObjectVsBroadPhaseLayerFilter;

		// Entity-to-Body map
		std::unordered_map<UUID, JPH::BodyID> m_EntityToBody;

		friend class Physics;

		ColliderBodyActivationListener CBAL;
		ColliderContactListener CCL;
	};
}

//PhysicsController.cpp
#include "PhysicsController.hpp"

#include <Jolt/Physics/Collision/Shape/ScaledShape.h>
#include <Jolt/Physics/Body/BodyCreationSettings.h>
#include <Jolt/Physics/Collision/Shape/CompoundShape.h>

#define JOLT

#ifdef JOLT
namespace Cresta
{
	void PhysicsController::TraceImpl(const char* inFMT, ...)
	{
		va_list list;
		va_start(list, inFMT);
		char buffer[1024];
		vsnprintf(buffer, sizeof(buffer), inFMT, list);
		va_end(list);
		CRESTA_TRACE("{}", buffer);
	}

#ifdef JPH_ENABLE_ASSERTS

	bool PhysicsController::AssertFailedImpl(const char* inExpression, const char* inMessage, const char* inFile, uint inLine)
	{
		// Print to the TTY
		std::cout << inFile << ":" << inLine << ": (" << inExpression << ") " << (inMessage != nullptr ? inMessage : "") << std::endl;

		// Breakpoint
		return true;
	}
#endif // JPH_ENABLE_ASSERTS

	PhysicsController::PhysicsController()
	{
		RegisterDefaultAllocator();
		Factory::sInstance = new Factory();
		RegisterTypes();

		m_JobSystem = CreateScope<JobSystemThreadPool>(cMaxPhysicsJobs, cMaxPhysicsBarriers, thread::hardware_concurrency() - 1);
		m_TempAllocator = CreateScope<TempAllocatorImpl>(32 * 1024 * 1024);

		m_BodyInterface = &m_PhysicsSystem.GetBodyInterface();

		Init();
	}

	PhysicsController::~PhysicsController()
	{
		ClearBodies();
		delete Factory::sInstance;
		Factory::sInstance = nullptr;
		UnregisterTypes();
	}

	void PhysicsController::Init()
	{
		m_PhysicsSystem.Init(
			cm_NumBodies,
			cm_NumBodyMutexes,
			cm_MaxBodyPairs,
			cm_MaxContactConstraints,
			m_BroadPhaseLayerInterface,
			m_ObjectVsBroadPhaseLayerFilter,
			m_ObjectVsObjectLayerFilter);

		m_PhysicsSystem.SetBodyActivationListener(&CBAL);
		m_PhysicsSystem.SetContactListener(&CCL);
	}

	void PhysicsController::MakeBodyStatic(const UUID& EntityID)
	{
		m_BodyInterface->SetMotionType(m_EntityToBody[EntityID], EMotionType::Static, EActivation::Activate);
		ObjectLayer Layer = m_BodyInterface->GetObjectLayer(m_EntityToBody[EntityID]);

		if (Layer == Layers::Colliders)
		{
			return;
		}
		else if (Layer == Layers::MOVING)
		{
			m_BodyInterface->SetObjectLayer(m_EntityToBody[EntityID], Layers::NON_MOVING);
		}
	}

	void PhysicsController::RemoveCollider(const UUID& EntityID)
	{
		m_BodyInterface->SetObjectLayer(m_EntityToBody[EntityID], Layers::NoCollision);
	}

	void PhysicsController::ClearBodies()
	{
		for (auto& entity : m_EntityToBody)
		{
			m_BodyInterface->RemoveBody(entity.second);
		}
		m_EntityToBody.clear();
	}

	void PhysicsController::CreateBody(const UUID& EntityID)
	{
		if (m_EntityToBody.find(EntityID) != m_EntityToBody.end())
		{
			return;
		}
		RefConst<Shape> scaled_sphere_shape = /* new ScaledShape( */new SphereShape(1.0f)/*, {1.0f,1.0f,1.0f})*/;
		BodyCreationSettings settings(scaled_sphere_shape,
			RVec3(0, 0, 0),
			Quat::sIdentity(),
			EMotionType::Static, Layers::NoCollision);

		settings.mAllowDynamicOrKinematic = true;

		m_EntityToBody[EntityID] = m_BodyInterface->CreateAndAddBody(settings, EActivation::Activate);
	}

	void PhysicsController::AddCollider(const UUID& EntityID, const ColliderShape& shape)
	{
		CreateBody(EntityID);
		m_BodyInterface->SetObjectLayer(m_EntityToBody[EntityID], Layers::Colliders);

		BodyLockWrite lock(m_PhysicsSystem.GetBodyLockInterface(), m_EntityToBody[EntityID]);
		if (lock.Succeeded())
		{
			Body& body = lock.GetBody();
			switch (shape)
			{
			case ColliderShape::BoxCollider:
				body.SetShapeInternal(new BoxShape(cm_HalfExtents), true);
				break;
			case ColliderShape::SphereCollider:
				body.SetShapeInternal(new SphereShape(10), true);
				break;
			case ColliderShape::CapsuleCollider:
				body.SetShapeInternal(new CapsuleShape(cm_CapsuleHalfHeight, cm_Radius), true);
				break;
			}
			lock.ReleaseLock();
		}
	}

	void PhysicsController::SetColliderTrigger(const UUID& EntityID, bool IsTrigger)
	{
		BodyLockWrite lock(m_PhysicsSystem.GetBodyLockInterface(), m_EntityToBody[EntityID]);
		if (lock.Succeeded())
		{
			Body& body = lock.GetBody();
			body.SetIsSensor(IsTrigger);
			lock.ReleaseLock();
		}
	}

	void PhysicsController::AddRigidBody(const UUID& EntityID)
	{
		CreateBody(EntityID);
		m_BodyInterface->SetMotionType(m_EntityToBody[EntityID], EMotionType::Dynamic, EActivation::Activate);

		ObjectLayer Layer = m_BodyInterface->GetObjectLayer(m_EntityToBody[EntityID]);

		if (Layer == Layers::Colliders)
		{
			return;
		}

		m_BodyInterface->SetObjectLayer(m_EntityToBody[EntityID], Layers::MOVING);
	}


	void PhysicsController::SetBodyPosition(const UUID& EntityID, const glm::vec3& position)
	{
		BodyLockWrite lock(m_PhysicsSystem.GetBodyLockInterface(), m_EntityToBody[EntityID]);

		if (lock.Succeeded())
		{
			Vec3 Pos({ position.x,position.y,position.z });

			Body& body = lock.GetBody();
			Vec3 BodyPos = body.GetPosition();
			Vec3 CenterOfMass = body.GetShape()->GetCenterOfMass();

			if (Pos == BodyPos)
			{
				lock.ReleaseLock();
				return;
			}

			body.SetPositionAndRotationInternal(Pos,body.GetRotation());
			lock.ReleaseLock();
			AABox Box = body.GetShape()->GetLocalBounds().Scaled(Vec3::sReplicate(10.0f));

			m_BodyInterface->ActivateBodiesInAABox(
				Box,
				m_PhysicsSystem.GetDefaultBroadPhaseLayerFilter(body.GetObjectLayer()),
				m_PhysicsSystem.GetDefaultLayerFilter(body.GetObjectLayer())
			);
		}
	}

	void PhysicsController::SetBodyShapeOffset(const UUID& EntityID, const glm::vec3& CenterOfMass)
	{

	}

	void PhysicsController::SetBodyShapeRadius(const UUID& EntityID, float radius)
	{
		m_BodyInterface->SetShape(m_EntityToBody[EntityID],new ScaledShape(new SphereShape(1.0f),Vec3(radius, radius, radius)),true,EActivation::Activate);
	}

	void PhysicsController::SetBodyShapeScale(const UUID& EntityID, const glm::vec3& scale)
	{
		BodyLockWrite lock(m_PhysicsSystem.GetBodyLockInterface(), m_EntityToBody[EntityID]);

		if (lock.Succeeded())
		{
			Vec3 Scale({ scale.x,scale.y,scale.z });

			Body& body = lock.GetBody();

			Vec3 BodyScale = body.GetShape()->GetLocalBounds().GetExtent();
			Vec3 CenterOfMass = body.GetShape()->GetCenterOfMass();

			if (Scale == BodyScale)
			{
				lock.ReleaseLock();
				return;
			}
			BodyScale = Scale / BodyScale;
			Shape::ShapeResult new_shape = body.GetShape()->ScaleShape(BodyScale);
			if (new_shape.IsValid())
			{
				m_PhysicsSystem.GetBodyInterfaceNoLock().SetShape(body.GetID(), new_shape.Get(), true, EActivation::Activate);
			}
			lock.ReleaseLock();
		
			AABox Box = body.GetShape()->GetLocalBounds().Scaled(Vec3::sReplicate(10.0f));

			m_BodyInterface->ActivateBodiesInAABox(
				Box,
				m_PhysicsSystem.GetDefaultBroadPhaseLayerFilter(body.GetObjectLayer()),
				m_PhysicsSystem.GetDefaultLayerFilter(body.GetObjectLayer())
			);
		}
	}

	void PhysicsController::SetGravityFactor(const UUID& EntityID, float gravityfactor)
	{
		m_BodyInterface->SetGravityFactor(m_EntityToBody[EntityID],gravityfactor);
	}

	glm::quat PhysicsController::GetBodyRotation(const UUID& EntityID)
	{
		Quat bodyRotation = m_BodyInterface->GetRotation(m_EntityToBody[EntityID]);
		return {
			bodyRotation.GetW(),
			bodyRotation.GetX(),
			bodyRotation.GetY(),
			bodyRotation.GetZ()
		};
	}

	void PhysicsController::SetCapsuleHeightRadius(const UUID& EntityID, float HalfHeight, float Radius)
	{
		BodyLockWrite lock(m_PhysicsSystem.GetBodyLockInterface(), m_EntityToBody[EntityID]);
		if (lock.Succeeded())
		{
			Body& body = lock.GetBody();
			body.SetShapeInternal(new CapsuleShape(HalfHeight, Radius), true);
			lock.ReleaseLock();
		}
	}


	void PhysicsController::SetBodyRotation(const UUID& EntityID, const glm::quat& v_rotation)
	{
		glm::quat rotation = glm::normalize(v_rotation);
		m_BodyInterface->SetRotation(m_EntityToBody[EntityID], { rotation.x, rotation.y, rotation.z, rotation.w }, EActivation::Activate);
	}

	glm::vec3 PhysicsController::GetBodyPosition(const UUID& EntityID)
	{
		RVec3 bodyPosition = m_BodyInterface->GetCenterOfMassPosition(m_EntityToBody[EntityID]);
		return {
			bodyPosition.GetX(),
			bodyPosition.GetY(),
			bodyPosition.GetZ()
		};
	}

	void PhysicsController::Step()
	{
		const int cCollisionSteps = 1;
		m_PhysicsSystem.OptimizeBroadPhase();
		m_PhysicsSystem.Update(cm_DeltaTime, cCollisionSteps, m_TempAllocator.get(), m_JobSystem.get());
	}

	void PhysicsController::Start()
	{
		m_InitialStateRecorder.Clear();
		m_PhysicsSystem.SaveState(m_InitialStateRecorder);
	}

	void PhysicsController::Stop()
	{
		m_PhysicsSystem.RestoreState(m_InitialStateRecorder);
	}
}

#endif
\end{minted}
\newpage
\newpage
\begin{center}
    \textbf{\LARGE VI. SNAP SHOTS}\\[1cm]
\end{center}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output1.png}
    \caption{Main Menu}
    \label{fig:enter-label1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output8.png}
    \caption{Project Creation}
    \label{fig:enter-label2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output2.png}
    \caption{New Default Scene on Creation}
    \label{fig:enter-label}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output3.png}
    \caption{Model Loading}
    \label{fig:enter-label}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output4.png}
    \caption{Model Animation}
    \label{fig:enter-label}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output5.png}
    \caption{Model Movement With User Scripting}
    \label{fig:enter-label}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output6.png}
    \caption{Physics Demo}
    \label{fig:enter-label}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Diagram/Output7.png}
    \caption{Large Scale Model Loading}
    \label{fig:enter-label}
\end{figure}
\newpage

\begin{center}
    \textbf{\LARGE VI. REQUIREMENTS}\\
\end{center}

\begin{enumerate}[label={}]
\item \textbf{I. Assimp} – The Open Asset Import Library (Assimp) is utilized for importing 3D models in various formats (e.g., .obj, .fbx, .dae). It abstracts the parsing of complex model data including meshes, bones, animations, and materials, enabling consistent internal representation across different asset sources.

\item \textbf{II. entt} – A performant, header-only Entity Component System (ECS) library for C++ that manages game object composition and runtime data efficiently. It decouples object logic and promotes modular design, essential for real-time systems like game engines.

\item \textbf{III. GLAD} – An OpenGL function loader generator that handles dynamic loading of OpenGL functions based on the context’s supported version. It ensures compatibility and access to modern graphics pipeline features across platforms.

\item \textbf{IV. GLFW} – A cross-platform library responsible for creating and managing OpenGL contexts, windows, and handling input devices (keyboard, mouse, etc.). It serves as the foundational platform abstraction layer for rendering and event handling.

\item \textbf{V. GLM} – OpenGL Mathematics (GLM) is a header-only C++ mathematics library that adheres to GLSL (OpenGL Shading Language) specifications. It provides core linear algebra types and operations (matrices, vectors, quaternions) required for graphics transformations and camera logic.

\item \textbf{VI. IMGUI} – An immediate-mode GUI library designed for real-time applications. It is used to build editor interfaces, debug panels, and runtime tools that directly reflect and manipulate engine state with minimal overhead.

\item \textbf{VII. IMGUIZMO} – An IMGUI extension offering 3D transformation gizmos (translate, rotate, scale) typically used in scene editors. It provides intuitive manipulation of entity transforms within the engine’s graphical user interface.

\item \textbf{VIII. JSON} – Employed for data serialization and deserialization, using libraries like `nlohmann/json`. It is primarily used for saving and loading engine configurations, scene hierarchies, and runtime data in a structured and readable format.

\item \textbf{IX. LUA} – A lightweight, embeddable scripting language that integrates with the engine to define game behavior, event triggers, and logic at runtime. Its integration allows rapid prototyping and live iteration without recompiling the engine.

\item \textbf{X. SOL2} – A high-performance C++ library that binds C++ classes, functions, and objects to Lua scripts. It provides seamless interoperation between Lua and engine internals, enabling safe and efficient script-driven control over engine functionality.

\item \textbf{XI. spdlog} – A header-only C++ logging library that provides high-performance logging with formatting, multi-threaded support, and log file output. It is critical for tracking internal engine states and debugging runtime behavior.

\item \textbf{XII. stbi\_image} – A single-header image loading library from the stb collection, used for loading 2D textures from various file formats (e.g., PNG, JPG, BMP) into OpenGL-compatible memory representations.

\item \textbf{XIII. yaml-cpp} – A YAML parser and emitter written in C++ used for reading and writing configuration files. It is leveraged for settings that benefit from hierarchy and human readability, such as scene metadata, editor preferences, or scripting configurations.
\end{enumerate}

\newpage
\begin{center}
    \textbf{\LARGE VII. APPLICATIONS}\\
\end{center}

The Cresta Game Engine is a modular, extensible, and real\-time 3D game engine designed to facilitate the development of interactive applications, simulations, and games. By integrating a broad ecosystem of open-source libraries and a robust internal architecture, the engine provides developers with a flexible and performant platform to build content-rich experiences. The engine’s core architecture leverages an Entity-Component-System (ECS) paradigm via entt, which allows for decoupled logic and efficient data-oriented processing of game entities.

One of the primary capabilities of the engine is its advanced asset pipeline, enabled through Assimp for model importing and stb\_image for texture handling. This allows artists and developers to bring complex 3D models (e.g., .fbx, .obj, .dae) into the engine with full support for mesh hierarchies, skeletal animations, and embedded textures. These assets can be transformed, rendered, and manipulated in real time using an OpenGL-based rendering backend. The graphics stack is managed through GLAD and GLFW, ensuring compatibility with modern rendering features and providing cross-platform windowing and input support.

Cresta features a fully integrated editor GUI, built with ImGui and extended via ImGuizmo, providing developers with real-time scene editing capabilities. Users can manipulate entities directly in the viewport using transformation gizmos and modify component properties through custom editor panels. These tools significantly accelerate development workflows, especially during level design and debugging stages.

In terms of scripting and runtime control, the engine embeds the Lua scripting language with bindings provided by sol2. This integration allows for dynamic definition of game logic, event-driven behavior, and interactive scripting without recompilation. Developers can expose engine functions, register component types, and create gameplay systems that are extensible by designers through Lua scripts.

The engine also supports robust scene serialization, utilizing both JSON and yaml-cpp for storing and restoring complete scene hierarchies, object configurations, and user-defined data. This enables persistent storage of game states and seamless integration of user content, making it ideal for creating tools or games that rely on modifiability or external data.

In addition, spdlog provides advanced logging and diagnostics, crucial for debugging complex systems in real time. Developers can trace runtime events, capture performance metrics, and log errors with minimal performance overhead.

Overall, the Cresta Game Engine is equipped to handle a wide range of real-time 3D applications — from level editors, sandbox-style games, architectural visualizations, to simulation-based tools. Its modularity, scriptability, and tool-rich environment make it a powerful foundation for both rapid prototyping and full-scale development.

\newpage

\begin{center}
    \textbf{\LARGE VIII. LIMITATIONS}\\
\end{center}

\section*{Limitations of the Cresta Game Engine}
\addcontentsline{toc}{section}{Limitations of the Cresta Game Engine}

While the Cresta Game Engine provides a robust foundation for real-time 3D applications and interactive content, several limitations exist due to the current scope of implementation and architectural choices. These constraints are outlined below to provide a clear understanding of areas requiring further development or optimization.

\begin{itemize}
    \item \textbf{Lack of Advanced Rendering Features:} The current rendering pipeline is limited to forward rendering and lacks support for modern techniques such as deferred shading, screen-space ambient occlusion (SSAO), and physically based rendering (PBR). This restricts the engine’s visual fidelity in high-end applications.

    \item \textbf{Single-threaded Execution:} Most of the engine subsystems (rendering, logic update, resource loading) are executed on the main thread. This can become a performance bottleneck in scenes with high object counts or complex scripts, limiting scalability and responsiveness.

    \item \textbf{Limited Scripting API Exposure:} While Lua is embedded via `sol2`, only a subset of the engine’s functionality is exposed to scripts. This limits the expressiveness and control that scripters have over runtime behavior and engine customization.

    \item \textbf{No Networking or Multiplayer Support:} The engine is designed for single-player applications only. There is currently no support for real-time networking, client-server architecture, or multiplayer synchronization mechanisms.

    \item \textbf{Inadequate Asset Management System:} Assets are loaded at runtime via absolute or hard-coded paths, without a centralized import pipeline or metadata tracking system. This may lead to redundant resource usage and difficult asset dependency resolution.

    \item \textbf{Platform Limitation:} The engine is primarily tested on Windows environments. Although dependencies are cross-platform, the absence of platform abstraction layers for input, filesystem, and windowing reduces portability to Linux and macOS.
\end{itemize}

These limitations provide clear direction for future improvements and feature additions. Addressing them will enhance the engine's viability for both commercial and research-grade applications.

\newpage
\begin{center}
    \textbf{\LARGE IX. FUTURE SCOPE}\\
\end{center}
The Cresta Game Engine, while functional in its current state, has significant potential for expansion and refinement. This section outlines the planned enhancements and future development goals aimed at addressing the limitations discussed previously.

\begin{itemize}
    \item \textbf{Integration of Physically Based Rendering (PBR):} To improve visual fidelity, a deferred rendering pipeline with PBR will be implemented. This will allow the engine to simulate realistic material properties under varying lighting conditions, supporting albedo, normal, roughness, and metallic maps.

    \item \textbf{Physics Engine Integration:} The incorporation of a physics engine such as \texttt{Jolt Physics} or \texttt{Bullet} will enable simulation of rigidbodies, colliders, constraints, and collision detection. This will open up the possibility for physically accurate gameplay mechanics and object interactions.

    \item \textbf{Multithreaded Task System:} To improve performance scalability, especially in large scenes, a job-based multithreading system will be introduced. Resource loading, animation updates, and logic systems will be offloaded from the main thread to improve frame rate and responsiveness.

    \item \textbf{Advanced Animation Framework:} A robust animation system featuring blend trees, animation state machines, and runtime transitions will be developed. This will provide greater control over character and object animations in dynamic environments.

    \item \textbf{Expanded Lua Scripting Interface:} More engine subsystems will be exposed to Lua through \texttt{sol2}, including rendering, physics, UI elements, and event dispatching. This will allow designers and scripters to build complete gameplay systems without modifying the core engine.

    \item \textbf{Editor Feature Enhancements:} The editor will be extended with features such as asset browser integration, prefab creation, undo/redo support, scene hierarchy drag-and-drop, and keyboard shortcuts. These additions will streamline the development workflow and improve user productivity.

    \item \textbf{Networking Layer for Multiplayer Support:} A low-level networking abstraction and synchronization layer will be added to support multiplayer applications. Features will include RPC (Remote Procedure Calls), state replication, and authoritative server simulation.

    \item \textbf{Centralized Asset Management System:} A resource manager will be developed to handle asset importing, caching, dependency tracking, and memory usage. Metadata-based asset referencing will replace hardcoded paths to improve scalability and reliability.

    \item \textbf{Cross-Platform Portability:} A platform abstraction layer will be introduced to support deployment on Linux and macOS alongside Windows. This will involve handling platform-specific input, file I/O, and OpenGL context initialization.

    \item \textbf{Automated Build and Deployment Tools:} Scripts and systems for asset packaging, dependency bundling, and project exporting will be created. This will simplify the deployment of games and tools developed using the engine to end users.
\end{itemize}

These future enhancements are aimed at elevating Cresta into a more comprehensive and production-ready game development environment. Continued development in these areas will make the engine suitable for a wider range of use cases, including commercial game development, academic research, and real-time simulation applications.

\newpage 

\begin{center}
    \textbf{\LARGE X. CONCLUSION }\\
\end{center}

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

The development of the \textbf{Cresta Game Engine} represents a significant step toward creating a modular, extensible, and performant real-time 3D engine tailored for interactive applications. Throughout this project, core subsystems were designed and implemented, including an OpenGL-based rendering pipeline, an entity-component-system (ECS) architecture via \texttt{entt}, a user-friendly editor interface using \texttt{ImGui}, and a lightweight scripting interface through \texttt{Lua} and \texttt{sol2}. These components together provide a foundation for rapid prototyping, content authoring, and real-time simulation.

Despite the current engine being in an early stage, it demonstrates capabilities such as 3D model import, scene serialization, runtime scripting, and interactive in-editor manipulation. The architecture is built with extensibility in mind, allowing for future integration of advanced systems such as physically based rendering, animation blending, physics simulation, and multiplayer networking.

A detailed analysis of the limitations has helped identify areas that require architectural scaling, tooling refinement, and performance optimization. The outlined future scope provides a clear roadmap to evolve the engine from a functional prototype to a fully-featured, production-ready framework.

In conclusion, the Cresta Game Engine lays a strong technical groundwork for future innovation in real-time graphics and interactive systems. It serves not only as a learning platform but also as a practical tool that can be expanded into a powerful solution for real-world game development and visualization tasks.

\newpage
\begin{center}
    \textbf{\LARGE REFERENCES}\\
\end{center}
\begin{thebibliography}{99}
\addcontentsline{toc}{section}{References}

\bibitem{assimp}
Assimp – Open Asset Import Library. \textit{https://github.com/assimp/assimp}

\bibitem{entt}
M. De Gregorio, \textit{entt – Entity Component System (ECS) for C++}. \textit{https://github.com/skypjack/entt}

\bibitem{glad}
GLAD – Multi-Language GL/GLES/EGL/GLX/WGL Loader Generator. \textit{https://glad.dav1d.de}

\bibitem{glfw}
GLFW – An Open Source Multi-platform Library for OpenGL, OpenGL ES and Vulkan. \textit{https://www.glfw.org}

\bibitem{glm}
GLM – OpenGL Mathematics. \textit{https://github.com/g-truc/glm}

\bibitem{imgui}
O. Cornut, \textit{Dear ImGui}. \textit{https://github.com/ocornut/imgui}

\bibitem{imguizmo}
Cedric Guillemet, \textit{ImGuizmo – Gizmo for Dear ImGui}. \textit{https://github.com/CedricGuillemet/ImGuizmo}

\bibitem{nlohmann}
Niels Lohmann, \textit{JSON for Modern C++}. \textit{https://github.com/nlohmann/json}

\bibitem{lua}
Lua.org, \textit{The Lua Programming Language}. \textit{https://www.lua.org}

\bibitem{sol2}
ThePhD, \textit{sol2 – A C++ <-> Lua Wrapper}. \textit{https://github.com/ThePhD/sol2}

\bibitem{spdlog}
Gabi Melman, \textit{spdlog – Fast C++ Logging Library}. \textit{https://github.com/gabime/spdlog}

\bibitem{stb}
Sean Barrett, \textit{stb\_image – Image Loading Library}. \textit{https://github.com/nothings/stb}

\bibitem{yaml}
Jbeder, \textit{yaml-cpp – YAML Parser for C++}. \textit{https://github.com/jbeder/yaml-cpp}

\bibitem{opengl}
Khronos Group, \textit{OpenGL Specification}. \textit{https://www.khronos.org/opengl/}

\bibitem{gameengines}
Gregory, Jason. \textit{Game Engine Architecture}. A K Peters/CRC Press, 2017.

\end{thebibliography}


\end{document}